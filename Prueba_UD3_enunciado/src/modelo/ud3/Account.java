package modelo.ud3;
// Generated 31 mar 2023 8:53:10 by Hibernate Tools 4.3.6.Final

import java.math.BigDecimal;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.ManyToMany;
import javax.persistence.OneToMany;
import javax.persistence.Table;

/**
 * Account generated by hbm2java
 */
@Entity
@Table(name = "ACCOUNT")
//TODO: decidir la herencia
//@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
@Inheritance(strategy=InheritanceType.JOINED)
public class Account implements java.io.Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2581647321735867998L;
	protected int accountno; //cambiado a protected para el caso de la herencia T_P_C
	//private int accountno;
	private BigDecimal amount;
	private Set<Empleado> employees = new HashSet<Empleado>(0);
	private Set<AccMovement> accMovementsForAccountDestId = new HashSet<AccMovement>(0);
	private Set<AccMovement> accMovementsForAccountOriginId = new HashSet<AccMovement>(0);

	public Account() {
	}

	public Account(int accountno, BigDecimal amount) {
		this.accountno = accountno;
		this.amount = amount;
	}

	public Account(int accountno, BigDecimal amount, Set<Empleado> employees,
			Set<AccMovement> accMovementsForAccountDestId, Set<AccMovement> accMovementsForAccountOriginId) {
		this.accountno = accountno;
		this.amount = amount;
		this.employees = employees;
		this.accMovementsForAccountDestId = accMovementsForAccountDestId;
		this.accMovementsForAccountOriginId = accMovementsForAccountOriginId;
	}

	@Id
	//@GeneratedValue(strategy = IDENTITY)
	//Para el caso de herencia TABLE_PER_CLASS establecer AUTO 
	//@GeneratedValue(strategy = GenerationType.AUTO) 
	@Column(name = "ACCOUNTNO", unique = true, nullable = false)
	public int getAccountno() {
		return this.accountno;
	}

	public void setAccountno(int accountno) {
		this.accountno = accountno;
	}

	@Column(name = "AMOUNT", nullable = false, scale = 4)
	public BigDecimal getAmount() {
		return this.amount;
	}

	public void setAmount(BigDecimal amount) {
		this.amount = amount;
	}

	@ManyToMany(fetch = FetchType.LAZY, mappedBy = "accounts")
	public Set<Empleado> getEmployees() {
		return this.employees;
	}

	public void setEmployees(Set<Empleado> employees) {
		this.employees = employees;
	}

	//TODO
	//cambio mappedBy autogenerado - revisar refs. resto proyecto
	//CascadeType javax.persistence: REMOVE ?, hibernate: DELETE - REVISAR SI SON LO MISMO - que sustituye DELLETE-ORPHAN en JPA?
	@OneToMany(fetch = FetchType.LAZY, mappedBy = "accountDestino", cascade = CascadeType.REMOVE)
	public Set<AccMovement> getAccMovementsForAccountDestId() {
		return this.accMovementsForAccountDestId;
	}

	public void setAccMovementsForAccountDestId(Set<AccMovement> accMovementsForAccountDestId) {
		this.accMovementsForAccountDestId = accMovementsForAccountDestId;
	}

	//cambio mappedBy autogenerado - revisar refs. resto proyecto
	//8. añadida anotacion cascade - para que elimine los movimientos al eliminar la cuenta 
	// que sustituye DELLETE-ORPHAN  en JPA?
	@OneToMany(fetch = FetchType.LAZY, mappedBy = "accountOrigen", cascade = CascadeType.REMOVE)
	public Set<AccMovement> getAccMovementsForAccountOriginId() {
		return this.accMovementsForAccountOriginId;
	}

	public void setAccMovementsForAccountOriginId(Set<AccMovement> accMovementsForAccountOriginId) {
		this.accMovementsForAccountOriginId = accMovementsForAccountOriginId;
	}

	//Ya que Hibernate no gestiona automáticamente el establecimiento de relaciones bidireccionales M:N
	//Para evitar problemas es buena práctica establecer las relaciones bidireccionales explícitamente:
	//Creando un metodo:
	public void addEmpleado(Empleado emp) {
		getEmployees().add(emp);
		//conviene usar getEmployees() en lugar de this.employees para forzar las
		//inicializaciones de los objetos proxy en caso de inicialización lazy
		emp.getAccounts().add(this);
	}
	
	public void removeAccOrigMov(AccMovement accOrgMov) {
		getAccMovementsForAccountOriginId().remove(accOrgMov);
		accOrgMov.setAccountOrigen(null);
	}
	
	public void removeAccDestMov(AccMovement accDestMov) {
		getAccMovementsForAccountDestId().remove(accDestMov);
		accDestMov.setAccountDestino(null);	
	}
	
	
	
	@Override
	public String toString() {
		return "Account [accountno=" + accountno + ", amount=" + amount + "]";
	}
	
	

}
